// Load in dependencies
var cp = require('child_process'),
    spawn = cp.spawn,
    exec = cp.exec,
    EventEmitter = require('events').EventEmitter,
    nimble = require('nimble');

// Set up helper to properly kill children on Windows and Linux
// ANTI-PATTERN: Variables are non-expandable types (i.e. not objects), any new features will alter signature.
var isWindows = process.platform === 'win32';
function killChild(child, signal) {
  // If we are on Windows, kill it via CLI and the entire tree
  // TODO: Move to tree-kill once PR is merged
  if (isWindows) {
    exec('taskkill /pid ' + child.pid + ' /T /F');
  } else {
  // Otherwise, kill it the normal way
    if (signal) {
      child.kill(signal);
    } else {
      child.kill();
    }
  }
}

/**
 * Spawn for a single child. Always guarantees only one child exists
 * @see child_process.spawn
 * @param {String} cmd Command to run
 * @param {String[]} [args] Array of arguments to pass with cmd
 * @param {Object} [options] Options to pass to `spawn` and for ourselves
 * @param {Mixed} [options.killSignal] Signal to pass to `kill` executions
 */
var CHILDREN = [];
function SingleChild(cmd, args, options) {
  // If there are arguments, fallback options
  if (Array.isArray(args)) {
    options = options || {};
  } else {
  // Otherwise, fallback args
    options = args || {};
    args = [];
  }

  // Save arguments to starting/restarting
  this.cmd = cmd;
  this.args = args;
  this.options = options || {};

  // Save the child for self killing
  CHILDREN.push(this);

  // Call the EventEmitter constructor
  EventEmitter.call(this);
}
var SingleChildProto = {
  start: function (cb) {
    // Emit a start and proxy to restart
    return this.restart.apply(this, arguments);
  },
  /**
   * Stop the currently running child and start a new one
   * @param {Function} [cb] Error-first callback that returns *before* the child starts
   * @callback {Error|Null} err Error if there was one
   * @callback {ChildProcess} child Child that was started. Generated by node's ChildProcess#spawn
   */
  restart: function (cb) {
    // Stop the child
    var that = this;
    this.stop(function killedChild (code) {
      // Spawn a new child and emit start events
      that.emit('starting');
      var child = spawn(that.cmd, that.args, that.options);
      that.child = child;
      that.emit('started', child);

      // If the child leaves
      child.on('exit', function (code, signal) {
        // Unset the child
        that.child = null;

        // Emit an exit event
        that.emit('exited', code, signal);
      });

      // Callback with the child
      // DEV: It is important this runs before the child starts
      // so .stdout, .stderr hooks can be attached
      if (cb) {
        cb(null, child);
      }
    });
  },
  stop: function (cb) {
    // Emit a stop and proxy a SIGINT to kill
    return this.kill({signal: 'SIGINT'}, cb);
  },
  /**
   * Stop the currently running program
   * @param {Object} [options] Options for the kill action
   * @param {Mixed} [options.signal] Signal to use when killing
   * @param {Function} [cb] Callback to run when process has been killed.
   *     Receives same params as node's ChildProcess#exit event
   */
  kill: function (options, cb) {
    // Fallback options
    if (!cb) {
      cb = options;
      options = {};
    }

    // If there is no child, callback shortly
    var child = this.child;
    if (!child) {
      if (cb) {
        process.nextTick(cb);
      }
      return;
    }

    // Emit a killing event
    this.emit('killing', child);

    // When we leave, callback with the exit code
    var killSignal = options.signal || this.options.killSignal,
        that = this;
    child.on('exit', function cleanupChild (code, signal) {
      // Unset the child
      that.child = null;

      // Emit a killed event
      that.emit('killed', code, signal);

      // Callback with info
      if (cb) {
        cb(code, signal);
      }
    });
    killChild(child, killSignal);
  }
};
SingleChild.prototype = SingleChildProto;

// Duck-punch EventEmitter methods
var EventProto = EventEmitter.prototype,
    key;
for (key in EventProto) {
  SingleChildProto[key] = EventProto[key];
}

// When the process is leaving, kill all the children
function slaughterChildren () {
  nimble.each(CHILDREN, function killEachChild (singleChild, cb) {
    // Kill the child
    singleChild.kill(function (err) {
      cb();
    });
  }, function leaveGracefully (err) {
    process.exit(0);
  });
}
// TODO: This is probably overkill
process.on('SIGINT', slaughterChildren);
process.on('SIGHUP', slaughterChildren);
process.on('SIGTERM', slaughterChildren);
process.on('SIGUSR2', slaughterChildren);
process.on('exit', slaughterChildren);

// Export the child
module.exports = SingleChild;